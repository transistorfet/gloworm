
2023-08-07:
- I moved the OS out of the computie repository and into its own, with the git history preserved
- It will now be known as gloworm, named after the 1980s toy, since my Rust OS was already named Ruxpin after Teddy Ruxpin, so I
  tried to stick to the same theme

2025-01-31:
- the previous time I was working on in this repository was November/December 2023 when I tried to get the monitor and kernel
  compiled in clang, and booted it using Moa.  I ran into the common bug where the MOVEA instruction is assumed to set the flags
  register, but it's the one exception where the flags don't get updated, so a comparison doesn't work.  And it usually affects the
  fputs implementation causing it to print all of memory starting with the welcome message, but never terminating at the null
  character.  I never got around to submitting a bug report
- I've started working on this again since Christmas when I built the k30p-VME, MemBird Woodcock, and CF Card.  I added some commands
  to the monitor to test the VME bus accesses, and test the CF card, and I've since managed to get the kernel booting on the k30p
  and run the network stack

2025-02-01:
- I've been trying to add a config system so that it's easier to conditionally compile things, and linux's config system looks
  simple.  I could try to learn cmake and/or ninja or something, but then anyone building it would have to install those too, and
  they don't look too straightforward for the kind of config I'd like
- Kconfig uses a simple file format for describing config settings and their relations, which generates a single file with all the
  config settings in them.  The config programs are distributed with debian, so they don't have to be included here, and even then,
  the output config file with eg. `CONFIG_M68K=y` is easily human readable and modifiable, it's valid make and bash syntax, can be
  parsed easily.  You do have to make sure the dependecies are satisfied when editing the output by hand, but that's minor.
- A question is whether it's best to try to match the linux config item names, or whether to change some names, like BLK_DEV_RAM
  calling RAMDISK or something instead.  It probably doesn't matter much since I'll eventually write Kconfig files with
  descriptions
- linux seems to not use very many non-bool config items, which makes sense, but I'm thinking of using many more if I can, for
  parameters like device sizes and maybe address offsets for I/O register addresses.  I can't seem to find where linux configures
  those, if it has them configurable at all.  For a lot of systems, they'd all be in the same location, but for me, the ATA device
  on computie is 0x600000 but on computie-vme with the COMET CF Card, it's 0xff800000 or anything in the 0xffxxx000 range I think

2025-02-04:
- there's a lot of issues to fix, but it at least seems to be compiling the kernel and the monitor enough to boot them
- it turns out I was looking in tools/build/Makefile.build in the linux source, but it was scripts/Makefile.build that has the
  more complex build system, which has multiple special variables for targets, and it treats them somewhat specially, so I figured I
  should do the same so I have more control over what gets built how instead of over-generalizing
- I added the userprogs variable with pretty much the same rules to separate out single source file programs from multi-file ones,
  but I haven't tested the multi one yet
- it's building the final step when it shouldn't, and I still need to add the libc makefiles

2025-02-07:
- finally get the new build system implemented.  I had to make some special cases with subdir-y and others to make it build the
  right things, or else it would get confused by too many generic rules.  I still don't have it stripping the binaries for the
  commands yet, but that will come soon

2025-02-08:
- I brought out the k30 and 68k-SMT boards to test the builds on those.  Initially, neither board wanted to boot up.  After a while
  of trying, I finally got the 68k-SMT to run, but it was getting a lot of mistaken characters, not entirely garbage but adacent
  lower case letters, so I guess it was the lower data bits that were getting corrupted occasionally.  It seemed to run ok, printing
  the help text and such, but the characters printed and received were wrong, so maybe something localized to the serial controller
  or FTDI
- the k30-SBC just wouldn't do anything, and then it would print the welcome message but not the prompt, and then it would print the
  prompt but not accept characters, and then it would accept characters but hang when enter was pressed.  Finally I tried a
  different USB port instead of the one on the monitor stand, I used the one connected by the USB3 type-A extension cable and it
  worked
- I was eventually able to get both builds of the kernel and monitor running on them with the ATA drivers using the CONFIG_ATA_BASE
  select as the only difference, so the new build system should work with those boards

2025-02-16 [from retroverse logs]:
- I'm kind of getting sidetracked now, I tried to compile the kernel without -O3 in order to test if the optimizations are causing a
  problem, after reading in the computie logs that I had to add a volatile to strlen in order to get the monitor working previously
  because otherwise it was hanging.  It's very possible a similar thing is happening here with the kernel, so I thought it would be
  quick to check, but then I ran into a problem with undefined fwrite, which is almost certainly related to the wrong object files
  being added to the lib because it compiles both versions of libc.  The only place that fwrite exists that would cause the
  undefineds is in fputs, which is used by fputs in os/ but not in none/
- I compiled it with just the kernel and it worked without errors because it was monitor that had the problem
- trying to load it over serial caused the k30 to reset and run the monitor and start printing out the data instead of reading it
  in.  It was working before I used the unoptimized kernel.  *sigh*  I feel like I had this recently with one of the 3 boards I've
  been playing with
- ok I just checked and it's 100% because the kernel overflows the size that the load script handles (16-bit length) so it loads the
  first ~0x1800 bytes and then boots, but there's more data to send, so I need to keep that in mind now that I have such a big
  kernel.  I could modify the format to use a 4 byte number instead, but I guess I'd have to upgrade the roms on the other boards?
  I'd rather not use a backwards compatible mechanism.

2025-02-17:

- when it works, it switches to the command process and runs that for a while, and before it finishing writing its output, it exits
  and switches to the shell process to handle the exit code, and then to idle again, which switches a couple of times before the
  command's output finishing printing.  It would seem odd that it doesn't have to flush the output before the process exits...
- when it doesn't work, it switches from the command process to the idle process without going through the shell process, and
  the suspend_proc call is made, so it's suspending without exiting.  One of the cases had it switch back to the same command
  process once, before switching to the idle process on the next timer interrupt
- it's calling suspend from the tty write function, which is really just a pass through to the 68681 driver. I don't know why it
  doesn't suspend in 68681 when the only way it could return 0 is if it suspends, but either way, it's not waking up after the
  buffer clears
- it honestly doesn't look hard to add a resume check for tx to the bottom half, or a flush function.  You should make one anyways
  to wait for output to be send before exiting.  I think that comment about never waking up in pipe either was more specifically
  about writing more than the total buffer at once rather than just remaining buffer, or it was before i had the bh stuff. I want
  to clean up the various parts of that

2025-02-18:

- an extra print statement shows it does return 0 like normal from tty_68681_write but it skips the suspend step because O_NONBLOCK
  is set, probably to make the tty driver work correctly, which is why tty_write is the one that suspends.  Either way, it should be
  possible to add a resume
- I added a very quick "if buf not full then call resume_suspended_procs" to the bottom half handler of the tty68681 driver.  At
  first I added one that passes in the tty68681 major device number, and that didn't work because it's the tty driver that suspends,
  but adding a second call that passes in the tty major fixed it up a treat.  It can now print the entire bin listing, suspending at
  least twice during the process, but being woken up both times once the buffer is empty.  So that was the entire problem with the
  listing hanging
- I don't know why I didn't do it earlier.  Maybe I just didn't like doing a double call to resume and wanted to instead put it in
  the tty driver.  It is true that's it's not the most clean, but it's not that unusual since the tty68681 driver is really a
  subdriver of the tty subsystem.  Maybe there's a cleaner way, but at least it doesn't hang anymore

2025-02-22:

- I finally got a refactor done that I had thought would be quick, but ended up taking me 2 days or so.  Even though the standard
  libc and unix are codependent, I kind of had hoped to separate the kernel arch includes from the libc ones, and went back and
  forth a bit, but eventually settled on having src/libc/arch/<arch>/include, and src/kernel/arch/<arch>/include rather than putting
  them together in include/.  I know the existing libc and kernel includes are mixed together, but it's only kernel stuff in
  include/kernel/ and the rest is libc.  Then again I'm still having my doubts
- I also changed the byteorder to_le16, etc functions into endian.h htole16, etc which is posix standard, so the things that use it
  will be more portable to another libc, which might be wanted in some cases
- also using the libc none with other baremetal code easily without needing the kernel

- I also fixed some build issues.  The CFLAGS weren't applying to all downstream directories like I wanted, and I also needed to
  refactor the arch-specific ones so I make a bunch of minor changes.  CFLAGS works now because it doesn't get overwritten in the
  Makefile.defaults file on every decent, and ccflags-y works only for the current directory
- I also added a userprog-ccflags-y, firmware-ccflags-y, and kernel-ccflags-y, which are activated by the respective directory's top
  level Makefile by transfering it to CFLAGS.  The idea is that anything in those categories should get certain general flags that
  are architecture-specific like `-mpcrel` which applies to monitor and boot (firmwares), but not userprogs or the kernel.

2025-02-28:

- I'm working on making it possible to generically register interrupt handlers so that other drivers can be made besides the serial
  driver, and I've had it working for a few days now, in theory, but I'm also re-evaluating how I do contexts, and how I can improve
  it.  I'd like to add the option of doing user mode switching, but there's a limited number of %usp instructions, so I'd have to
  %a6 instead of %a7 to push all the data onto the stack.  There's also the option of not using the stack, although it looks like
  linux is using the stack where on x86 I'm pretty sure it saves the registers in a struct in the process object.
- I'm also not too happy about the double table (the first being the real vector table, and the second being the irq_action table).
  Right now they're the same size, but the second one can at least cut out the exceptions since they're not overridable.  I haven't
  looked closely enough at linux to know how it's storing them, but I want it to be fast, since they're interrupts, so I might still
  stick to a limited table.
- I tried removing the interrupt disable instruction at the entry of the two interrupt handlers I have, and it works when the irq
  handler doesn't have it, but the trap handler does need it.  The 68k only masks the interrupts if an actual hardware interrupt
  occurs, and not on a trap, and I guess without the disable on entry to the trap, it could have another interrupt while the trap
  handler is saving the instructions.  There's only a limited set of trap instructions with specific irqs, so I could get away with
  having the two different types of handlers.  It's maybe splitting hairs over one instruction, but I do still think they'll need to
  be different anyways

2025-03-01:

- I almost have a modified context switcher that can either do what it currently did of always using Supervisor mode, or optionally
  switch to/from User mode, and which in Supervisor-only mode switches to the kernel stack before pushing all the registers, but
  it's not quite working
- I thought I'd try running it on moa last night to "quickly" find the problem, and of course moa isn't working with computie, even
  after changing the memory map to match the VME card.  I can't seem to find where the error is coming from.  It's Emulator(Misc,
  "%d0"), but that error is only created with "Error::new" and all instantiations have a complete error message instead of just the
  register name, so I'm stumped.  The code is such a mess from the time I tried adding emulator-hal.  I really need to pick it up
  and fix it, but I want to work on gloworm first
- ah! the trace function isn't even advancing the instruction, so no wonder it wasn't hitting the fault when tracing in moa

2025-03-02:

- I got thrown off by the fact that I had disabled ATA in the config, but also needed to change the boot stuff as a result.  I need
  to fix how it gets the wrong boot arguments, and also make the boot arguments default use the config value, so it's consistent

2025-03-15:

- I've been trying to rewrite the context switching code for two weeks now, and ...
- I just wandered off and did something else.  It's not that it's hard to do, but I keep just doing other things instead of working
  on it, when I set down to work on it.  Not sure if it's an effect of the medication, or a lack of interesting, or what.  But that
  said, I *do* want to only do it once, and I'm trying to incorporate everything, and read the linux m68k context switch code to
  figure out how it does it
- namely, in arch/m68k: entry.S and include/asm/entry.h
- interestingly enough, it seems to only save the higher numbered registers when it actually switches processes, and otherwise it
  doesn't touch them.  And it can do this because even though it enters the kernel's C code, as long as it doesn't actually change
  states until it's returned all the way up the call stack, out of each re-entry of the kernel, and is finally ready to return from
  the irq or syscall that entered the kernel, the stack will be exactly back to when it entered, and all the extra registers will
  have been restored as part of the C calling convention to preserve their values on the stack.  It will be as if it had just
  entered, and only pushed the scratch registers on the stack.  I'm pretty sure this is what was meant when I read that now all
  interrupts were the "fast interrupt" in Linux, as in it only saves the full context state if it's switching and otherwise only
  saves the minimum (ish) by default

- So, what I want is:
    - to be able to get the interrupt number that occurred (for the handler lookup table)
    - to configurably do what it currently does of only using the supervisor stack, or optionally using user mode
    - save the system call on the stack in a way that doesn't duplicate the values like it currently does
    - don't save all the registers unless a task switch is actually going to happen

- I think that's it.  The questions I still need to answer are: should I always save the systemcall registers, whether in a system
  call or not, or only when in a syscall instead of irq, and how do I know which is which when looking at the stack?
- also, should I keep my syscall register assignments or copy linux which uses %d1-%d5 primarily, still can't find a good reason why,
  Minix on Mac might use the same as I am, but it looks like it uses a movem to save %d0-%d2/%a0-%a1 instead of the weird order I
  have... this is kind of minor by comparison

- for the first question, I'm pretty sure linux saves all of %d0-%d5/%a0-%a2, which are all the syscall registers plus some (still
  don't know why %a2 specifically), but either way, every interrupt always saves those registers, so it doesn't try to be too fancy
  and have two ways of entering?  It looks like it.  That would certainly be easier
- ah, I have them in the slightly weird order they're in (%d0, %d1, %a0, %a1, %d2, %d3) based on the read and write syscalls, which
  (SYSCALL3) which takes an integer (%d1), and then a pointer and size (which is pointer-like).  Interestingly enough, I don't have
  any SYSCALL5's, even though I've defined it (and not 4).  Oh it's just not in unistd, but it's in socket.  And there it looks like
  it doesn't make much sense... "a" registers have int flags and the ints in %d2 and %d3 are the actual pointers

2025-03-16:

- Ohhh!  Linux is using a different kernel stack *for each task*.  That's why the context switch seemed a bit weird.  It pushes the
  basic registers to the kernel stack and I think it also keeps the exception frame on there as well.  That's why it doesn't seem to
  copy anything from the kernel stack to the user stack when switching tasks.  It just stores all the data on the kernel stack.
- I'm not sure why it's doing this yet (other than convenience, if you have lots of memory).  Unless there's a better reason, maybe
  I should avoid this to keep the memory usage down?
- what happens when a signal occurs?  I think that's the only weird case where you'd end up with 2 contexts on the user stack

- I'm kind of thinking, at least for now, I'll use only one kernel stack (per cpu, but only one cpu atm), and that kernel stack will
  always be in the ISP stack pointer, which is backwards compatible.  I won't make use of the MSP or the M bit for the time being.
- is it worth it to always switch the stack to the user stack, push the context, and then switch back to the same kernel stack and
  only push the rest of the context when switching, even though switching is probably going to be quite frequent.  Or should you
  push it to the kernel stack along with the exception frame, and copy it to the user stack when switching fully?
- or is it even best to push a0 to kernel stack, use it to push context to user stack, etc

2025-03-18:

- I think I will eventually move to a kernel stack per thread model, but for now I'll just do a single kernel thread and change
  things over more slowly.  I don't even have threads yet

2025-03-23:

- Making progress, but still don't have a working context switch that delays the switch until it's returning, and only switches if
  it's actually changing processes
- so a little while ago I figured out that there was an issue with returning from a syscall, and that was because the code that set
  that value is manipulating the context itself on the user stack.  This is a major point to note when changing the context layout.
  Previously, the register %d0 was at the top of the stack, but that's not the case now, if the extra regs are only pushed as
  needed.
- I caught this by make it do the full switch but using the new macros.  I had it working when the extra regs were pushed before the
  syscall regs, but not in the opposite direction.  Greping the code found places where proc->sp was being used, and that lead to
  finding the issue.  I moved that code to a function in syscall_entry.S so that it would be more obvious that that was happening.
  The code that actually set it was in schedule.c, so it's not supposed to know about the context format anyways
- the symptoms were that it would appear to hang when starting multitasking, but it was still context switching according to the LED

- I then tried to get the delayed switch working, and that's been a nightmare.  It usually gives a privillege violation, because the
  flags register ends up being 0 due to an invalid stack.  Using the moa emulator, I was able to figure out that (at least in some
  cases), it was doing the switch correctly the first few times, but not after that
- there is an issue with starting multitaskings since the context needs to not try to save the previous process, which is NULL.  I
  had some code to check if the previous_proc was null, but that was maybe causing more issues, so I disabled it, and that caused
  different issues
- one of the problems was that it was restoring the current_proc stack, and then saving the previous_proc stack, and not looking at
  the current_proc value again before popping, but if the check to see if the proc is the same is disabled, then it won't use the
  updated sp when popping current_proc, so for now I have it switch to current, switch to previous, and then switch back to current
- It was still having a bad switch somewhere, and moa with a breakpoint just before it starts the stack manipulation found that
  after 4 or so switches, it messes up, when trying to pop off a new stack.  The stack doesn't have the full context on it, so when
  the switching code does the swap, it pops the extra regs off the stack which aren't there and thus later on pops the wrong data
  during rte
- more grepping of the code didn't find the issue, because I didn't look at the code around it.  I tried setting a breakpoint on the
  signal code because that involved some stack manipulation, but that didn't get hit before the bad switch happened
- I can't quite remember how I clued into the process clone.  I might have been looking at new_proc and stuff, but somewhere along
  the line, I realized that the process cloning/fork was the problem.  It's cloning the current process which has an incomplete
  context on its stack, and so when it goes to actually switch procs, the new proc doesn't have the extra regs, only the syscall
  regs!
- fixing this made the privillege violation stop, so it's successfully switching, but it now hangs before the shell starts.  I
  *think* that might be because of the return value again.  I think the problem in general is that the context on the stack is not
  consistent.  If you're doing something with the stack of the current proc, then it's only got the syscall, and if you're doing
  something with any other process, it has the extended stack
- nope, trying to conditionally set the return value in the context doesn't fix the problem.  It seemed to instead make context
  switching halt.  When it's swapped from what it should be, it continues context switching and hangs before starting the shell

- ok so after a bunch of debugging, I realized that since the clone function is just subtracting some size for the extra registers
  (because it has no access to the extra registers that weren't saved before the syscall), they'll be all random values, and that's
  probably what's causing the emulator to jump to an address which is actually some instructions.  It almost works but won't work
  correctly unless those extra registers are actually cloned along with the rest of the process...
- So looking at linux, it has specific entry points for fork, clone, sigreturn, and a few others, which save the switch stack every
  time.  It feels a bit like cheating, because only "blessed" syscalls get the special treatment needed, but it's certainly more
  optimized/performant.

- This is the key point!  I'm pretty sure I knew this a few years ago too when I was looking at refactoring the context switch, but
  gave up at the time because it wasn't important then.  When using a switch that delays the full switch until necessary, you can't
  do it so casually.  You either need to have special entry points for the syscalls that could create a new task (or else the full
  state can't be cloned), or you need a way to delay the full clone/stack clone until exiting to a user process, so you can get the
  full state.  There's really no other way (besides always saving the full state or the non-recoverable state, MMU and FPU state
  could be delayed still, but integer regs state can't because of C and what it will do (ie. save regs as needed instead of putting
  them all in one place))

2025-03-28:

- looking at it more, I'm not sure how it actually uses those special entry points.  Oh I see, it's a table in assembly of entry
  points, which is the same as gloworm is doing but it C.  I could shave off a few instructions by not saving arguments on the stack
  but using the registers directly, and saving a jump instruction by putting the actual table call in assembly
- the special entry point would go in the syscall table (so jumps to C, the jumps back to the same entry file, and then back to a
  hard-coded syscall function in the same C syscall file as the jump.  Given that, it does kind of make more sense to move it to
  assembly.  There are those LED control calls in the C version, but actually I could make a syscall entry/exit hook with compiled
  in optional code like that, so it can be added or removed more easily with a kconfig setting

2025-03-30:

- I still haven't gotten back to this.  I had previously tried looking at linux's other archs to see the switching code, and I can't
  see that same trick that the m68k code has with redirecting the fork and clone syscalls.  I wonder if that was an older solution
  and the maintained archs have a newer better way of doing it, or if they're just really convoluted because they're more highly
  optimized
- I'm still thinking of doing the redirect solution.  The delayed clone might work too, and it would require less refactoring of the
  syscall code, but might be too complicated?  I guess you'd have to store a pointer to the new process, and check that pointer when
  returning to see if you need to complete the clone, and it would only work with a single clone/fork, even though that's likely
  all you'll ever need
- looking at the mips code, the fork/clone calls are wrapping in save_static_function, and there's a comment about that being
  replaced with SAVE_STATIC.  Etiher way, it seems that the same trick is in place to save some of the extended regs conditionally,
  but it's been made generic so any syscall  that needs it can access those values.  I don't really know how it works yet though

2025-04-08:

- I tried implementing the do_fork hook to save the regs before it actually clones the process.  I still have it using the
  do_syscall entry, but that should be ok because it's not using anything but the scratch registers during that, so the extra regs
  will still be preserved when it enters the new __do_fork.  That new entry saves the regs on the user stack of the current process,
  calls the normal entry (which doesn't take arguments anyways), clones the process, and returns to pop the extra registers again.
  I tried with both a sub instruction and a proper RESTORE, and both are causing a fatal exception, privillege violation, because
  it's popped the wrong value into the flags register and jumped to address 40, which is a MOVE to SR instruction.
- I have gotten this before, but I can't seem to find it in my notes.  I know it's because there's some kind of inconsistency in the
  user stack, but I haven't changed that as far as I can tell.  It should be working
- I inspected the stack of the process that failed (according to the stack trace) and couldn't find the expected flags value of
  0x2000.  On a hunch, I tried commenting out the set_proc_return_value function in the fork, since it will calculate the wrong
  address now, with the extra regs on the stack, and while it didn't work, it did at least avoid the fatal exception.  The LEDs are
  flashing to show it's context switching, but it's hanging, as it does
- I tried a hack where I change the value of current_proc, and it's still hanging, and only prints "forking 1" so it's not getting
  past the `init` process.  I feel like I'm close though


- I worked on this again tonight, and I've been going in circles of sorts, but still fixing issues in the process I think.  It
  either has a fatal error, or it hangs after the first fork, depending on what I change.  I thought it was just an issue with the
  return value, so I removed the explicit set function in the context, which needed to conditionally know where in the stack to
  store the return, and replaced it with a value in the proc struct that is set just before returning, but that uncovered a
  behaviour where it doesn't always set the return value, so I had check and reset the flag in the bits member of the proc struct
  when it sets the return value, and in the process removed a run check before setting, and then changed the logic of the bit to
  suit a bit better, and it's still fatal erroring
- I'm pretty sure the current issue is that it doesn't pop the extra registers for the process that is just starting after being
  cloned?  Well either way there's 9 extra long words on the stack (maybe 11 since the rte has already popped those off and caused
  the fatal to begin with).  So it seems like some other condition where it gets the logic wrong on whether to skip parts of the
  restore_context final work
- Ah! right!!! the problem is with exec.  I keep forgetting about exec.  Pretty sure I previously came across this, but this has
  been so drawn out over the last two months, I can't remember all the things I ran into.  I put a print statement on the syscall
  entry to trace what's going on, and it ends in EXECBUILTIN, which is probably trying to launch the shell.  The exec's context is
  probably wrong since it's actually the same current process, even though the executable is different.  create_context is wrong at
  least in this case

2025-04-09:

- I commented out the extra reg values in the create_context function so that when exec was called, and the current process was
  recreated, it would create a new short context so that it would restart properly, but that also fatal'd.  The syscalls were different
  though
- it was doing a bunch of syscall 4 (write), and then it does a syscall 3 (read) and fatals.  That's the first point where it would
  block.  So something else happens that breaks, possible the idle task or some other task that runs that doesn't have the right
  context.  I really need some way to know when creating the context if it's the current process or not
- I wonder if Linux has a similar thing, or if there's a higher level interface to the arch-specific context code, or if it doesn't
  need this difference for some other reason

- oh, just looking at RESTORE_ALL in linux's m68k arch, it's got two values on the stack that it pops off last.  One is the orig d0,
  and the other is a stack adjustment (according to the comment), but I don't yet know what value that is.  It's added to the
  existing stack pointer, so that makes me think it's inherently the size of the context.  It could be 0 if it's a full context and
  36 if it's a short context, and there's no conditional stuff.
- The same thing could be done with the d0 value, since it's comment is orig d0.  Store the value of d0 (in the struct process) when
  entering the context, and restore it when leaving.  That way you don't need flags.  You just restore whatever the value is, and
  it'll be updated with the syscall return if there is one.  That's much more efficient
- searching for the stack adjust value, and they're all clr instructions that set them, so it's not actually used in linux.  I
  wonder if it was used for the reason I'm thinking of using it, but it's been removed for some reason and is kept for legacy
  purposes, or it's expected of all architectures, and others use them but the m68k doesn't need it? *shrug*

2025-04-11:

- Ok I finally fixed the crashing, but it's still not getting to the shell.  I had to add a flag to create_context to selectively
  create an extended context or not.  When using exec on a proc that's the current proc, it will use an extended context, otherwise
  it won't.  That gets through both the initial process start (with the exceptional extended restore on first start), and also
  the initial switch to the idle task, which needs an extended context because it's not the first process run.  I think the
  remaining issue might be related to the return value still, which probably is still buggy
- the current approach is messy and fragile, so hopefully I can make it better by initializing the return d0 value when entering the
  kernel, and fixing the need for the extended context flag, or the exceptional case there.  Honestly, the easiest fix is of course
  to have two stacks per process, but I still want to avoid adding that just yet
- btw the issue I had with it not working last night was that the create context flag passed by C was a long word, so it was always
  using 0 instead of the actual extended flag value when creating the context, and always created a short context

2025-04-12:

- Today I'm going to consolidate the changes I've made that aren't related to the context, so I've got my changes stashed and
  re-applied so I have tho originals, and I've reverted the context changes and am adding back in the minimal changes needed to get
  the enter_exception and other non-asm changes working
- so far it's hanging with task switching working, so I'm pretty sure there's a problem with the return to user process and the
  return value itself, which makes sense.  The other changes to delay the full switch are probably working but the return value
  isn't which is causing the hanging behaviour I've been seeing in the full change

- I've spent all day trying to chase down why it's not working.  I'm not doing the delayed switch.  I went back to the first commit
  after main, 76c14006e0fd669b2b4aa3596a3ff12a8bbdde52, and that commit is broken for some reason, even though I thought it was
  working before I committed.  The syscall gets 0 as the number, so it prints the test message (syscall #0)
- the latest commit, f72add615976e9a5b021d3cc19b02ede7982ca76, fails for a different reason.  It seems to almost work but when it
  returns to the shell process, pid 3, the stack seems to be corrupted somehow.  My emulator doesn't behave the same way, but I've
  definitely got some bugs in the instructions, so not surprising.  It runs the init process alright, and I think it probably
  switches to the idle process at some point.  The init process does a fork syscall, and then waitpid, and when it should switch to
  the shell process, it either hangs or gives a format exception (stack format word is incorrect)

- hmm... when I reverted the changes to the proc struct, it started working enough to be switching tasks, but the return value is
  still likely wrong when the child fork returns because it's showing two waitpid calls (syscall#7), and then hangs, but the LED was
  flashing
- adding just the return value into the struct made it halt due to out of memory, so it's not happy with that
- moving the bits member makes the stack use 0xFFFFFFF7 as the size for some reason, which then makes it hang

- I don't know what's going on.  I fiddled with some things in the proc struct, and now it seems to be working with return_value up
  high.  I moved mem map to below the pid numbers and made the bits a uint32_t.  Not sure if there's a corruption issues somewhere

- alright, I have it working it seems.  It was of course the return value.  I finally got it to go in the proc struct, and I set it
  in the enter_syscall and enter_irq, and then always (instead of conditionally) set it on exit to user space, and that sort of
  worked but then it would go directly to the monitor as soon as a key was pressed...
- after a second of thinking, I figured it was probably the enter_irq, since that is re-entrant but I was storing it in the single
  process struct... so it was being overwritten.  The existing return code was complicated with the bit flag for a reason, because
  it's a tricky problem...
- moving the enter_irq d0 copy to the SAVE_CONTEXT macro, so it's only saved when entering from user mode, which only happens once.
  Otherwise it will do the normal kernel scratch registers entry.  I still have the syscall entry setting it to -1, but I think
  that's ok because it should always set that value anyways in the syscall handler code
- hmm... I wonder if that's why it was broken when I substituted the C version of the syscall handler... because I forgot to call
  the return_to_current_proc(ret) call

