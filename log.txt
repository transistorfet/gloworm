
2023-08-07:
- I moved the OS out of the computie repository and into its own, with the git history preserved
- It will now be known as gloworm, named after the 1980s toy, since my Rust OS was already named Ruxpin after Teddy Ruxpin, so I
  tried to stick to the same theme

2025-01-31:
- the previous time I was working on in this repository was November/December 2023 when I tried to get the monitor and kernel
  compiled in clang, and booted it using Moa.  I ran into the common bug where the MOVEA instruction is assumed to set the flags
  register, but it's the one exception where the flags don't get updated, so a comparison doesn't work.  And it usually affects the
  fputs implementation causing it to print all of memory starting with the welcome message, but never terminating at the null
  character.  I never got around to submitting a bug report
- I've started working on this again since Christmas when I built the k30p-VME, MemBird Woodcock, and CF Card.  I added some commands
  to the monitor to test the VME bus accesses, and test the CF card, and I've since managed to get the kernel booting on the k30p
  and run the network stack

2025-02-01:
- I've been trying to add a config system so that it's easier to conditionally compile things, and linux's config system looks
  simple.  I could try to learn cmake and/or ninja or something, but then anyone building it would have to install those too, and
  they don't look too straightforward for the kind of config I'd like
- Kconfig uses a simple file format for describing config settings and their relations, which generates a single file with all the
  config settings in them.  The config programs are distributed with debian, so they don't have to be included here, and even then,
  the output config file with eg. `CONFIG_M68K=y` is easily human readable and modifiable, it's valid make and bash syntax, can be
  parsed easily.  You do have to make sure the dependecies are satisfied when editing the output by hand, but that's minor.
- A question is whether it's best to try to match the linux config item names, or whether to change some names, like BLK_DEV_RAM
  calling RAMDISK or something instead.  It probably doesn't matter much since I'll eventually write Kconfig files with
  descriptions
- linux seems to not use very many non-bool config items, which makes sense, but I'm thinking of using many more if I can, for
  parameters like device sizes and maybe address offsets for I/O register addresses.  I can't seem to find where linux configures
  those, if it has them configurable at all.  For a lot of systems, they'd all be in the same location, but for me, the ATA device
  on computie is 0x600000 but on computie-vme with the COMET CF Card, it's 0xff800000 or anything in the 0xffxxx000 range I think

2025-02-04:
- there's a lot of issues to fix, but it at least seems to be compiling the kernel and the monitor enough to boot them
- it turns out I was looking in tools/build/Makefile.build in the linux source, but it was scripts/Makefile.build that has the
  more complex build system, which has multiple special variables for targets, and it treats them somewhat specially, so I figured I
  should do the same so I have more control over what gets built how instead of over-generalizing
- I added the userprogs variable with pretty much the same rules to separate out single source file programs from multi-file ones,
  but I haven't tested the multi one yet
- it's building the final step when it shouldn't, and I still need to add the libc makefiles

2025-02-07:
- finally get the new build system implemented.  I had to make some special cases with subdir-y and others to make it build the
  right things, or else it would get confused by too many generic rules.  I still don't have it stripping the binaries for the
  commands yet, but that will come soon

2025-02-08:
- I brought out the k30 and 68k-SMT boards to test the builds on those.  Initially, neither board wanted to boot up.  After a while
  of trying, I finally got the 68k-SMT to run, but it was getting a lot of mistaken characters, not entirely garbage but adacent
  lower case letters, so I guess it was the lower data bits that were getting corrupted occasionally.  It seemed to run ok, printing
  the help text and such, but the characters printed and received were wrong, so maybe something localized to the serial controller
  or FTDI
- the k30-SBC just wouldn't do anything, and then it would print the welcome message but not the prompt, and then it would print the
  prompt but not accept characters, and then it would accept characters but hang when enter was pressed.  Finally I tried a
  different USB port instead of the one on the monitor stand, I used the one connected by the USB3 type-A extension cable and it
  worked
- I was eventually able to get both builds of the kernel and monitor running on them with the ATA drivers using the CONFIG_ATA_BASE
  select as the only difference, so the new build system should work with those boards

2025-02-16 [from retroverse logs]:
- I'm kind of getting sidetracked now, I tried to compile the kernel without -O3 in order to test if the optimizations are causing a
  problem, after reading in the computie logs that I had to add a volatile to strlen in order to get the monitor working previously
  because otherwise it was hanging.  It's very possible a similar thing is happening here with the kernel, so I thought it would be
  quick to check, but then I ran into a problem with undefined fwrite, which is almost certainly related to the wrong object files
  being added to the lib because it compiles both versions of libc.  The only place that fwrite exists that would cause the
  undefineds is in fputs, which is used by fputs in os/ but not in none/
- I compiled it with just the kernel and it worked without errors because it was monitor that had the problem
- trying to load it over serial caused the k30 to reset and run the monitor and start printing out the data instead of reading it
  in.  It was working before I used the unoptimized kernel.  *sigh*  I feel like I had this recently with one of the 3 boards I've
  been playing with
- ok I just checked and it's 100% because the kernel overflows the size that the load script handles (16-bit length) so it loads the
  first ~0x1800 bytes and then boots, but there's more data to send, so I need to keep that in mind now that I have such a big
  kernel.  I could modify the format to use a 4 byte number instead, but I guess I'd have to upgrade the roms on the other boards?
  I'd rather not use a backwards compatible mechanism.

2025-02-17:

- when it works, it switches to the command process and runs that for a while, and before it finishing writing its output, it exits
  and switches to the shell process to handle the exit code, and then to idle again, which switches a couple of times before the
  command's output finishing printing.  It would seem odd that it doesn't have to flush the output before the process exits...
- when it doesn't work, it switches from the command process to the idle process without going through the shell process, and
  the suspend_proc call is made, so it's suspending without exiting.  One of the cases had it switch back to the same command
  process once, before switching to the idle process on the next timer interrupt
- it's calling suspend from the tty write function, which is really just a pass through to the 68681 driver. I don't know why it
  doesn't suspend in 68681 when the only way it could return 0 is if it suspends, but either way, it's not waking up after the
  buffer clears
- it honestly doesn't look hard to add a resume check for tx to the bottom half, or a flush function.  You should make one anyways
  to wait for output to be send before exiting.  I think that comment about never waking up in pipe either was more specifically
  about writing more than the total buffer at once rather than just remaining buffer, or it was before i had the bh stuff. I want
  to clean up the various parts of that

2025-02-18:

- an extra print statement shows it does return 0 like normal from tty_68681_write but it skips the suspend step because O_NONBLOCK
  is set, probably to make the tty driver work correctly, which is why tty_write is the one that suspends.  Either way, it should be
  possible to add a resume
- I added a very quick "if buf not full then call resume_suspended_procs" to the bottom half handler of the tty68681 driver.  At
  first I added one that passes in the tty68681 major device number, and that didn't work because it's the tty driver that suspends,
  but adding a second call that passes in the tty major fixed it up a treat.  It can now print the entire bin listing, suspending at
  least twice during the process, but being woken up both times once the buffer is empty.  So that was the entire problem with the
  listing hanging
- I don't know why I didn't do it earlier.  Maybe I just didn't like doing a double call to resume and wanted to instead put it in
  the tty driver.  It is true that's it's not the most clean, but it's not that unusual since the tty68681 driver is really a
  subdriver of the tty subsystem.  Maybe there's a cleaner way, but at least it doesn't hang anymore

2025-02-22:

- I finally got a refactor done that I had thought would be quick, but ended up taking me 2 days or so.  Even though the standard
  libc and unix are codependent, I kind of had hoped to separate the kernel arch includes from the libc ones, and went back and
  forth a bit, but eventually settled on having src/libc/arch/<arch>/include, and src/kernel/arch/<arch>/include rather than putting
  them together in include/.  I know the existing libc and kernel includes are mixed together, but it's only kernel stuff in
  include/kernel/ and the rest is libc.  Then again I'm still having my doubts
- I also changed the byteorder to_le16, etc functions into endian.h htole16, etc which is posix standard, so the things that use it
  will be more portable to another libc, which might be wanted in some cases
- also using the libc none with other baremetal code easily without needing the kernel

- I also fixed some build issues.  The CFLAGS weren't applying to all downstream directories like I wanted, and I also needed to
  refactor the arch-specific ones so I make a bunch of minor changes.  CFLAGS works now because it doesn't get overwritten in the
  Makefile.defaults file on every decent, and ccflags-y works only for the current directory
- I also added a userprog-ccflags-y, firmware-ccflags-y, and kernel-ccflags-y, which are activated by the respective directory's top
  level Makefile by transfering it to CFLAGS.  The idea is that anything in those categories should get certain general flags that
  are architecture-specific like `-mpcrel` which applies to monitor and boot (firmwares), but not userprogs or the kernel.

2025-02-28:

- I'm working on making it possible to generically register interrupt handlers so that other drivers can be made besides the serial
  driver, and I've had it working for a few days now, in theory, but I'm also re-evaluating how I do contexts, and how I can improve
  it.  I'd like to add the option of doing user mode switching, but there's a limited number of %usp instructions, so I'd have to
  %a6 instead of %a7 to push all the data onto the stack.  There's also the option of not using the stack, although it looks like
  linux is using the stack where on x86 I'm pretty sure it saves the registers in a struct in the process object.
- I'm also not too happy about the double table (the first being the real vector table, and the second being the irq_action table).
  Right now they're the same size, but the second one can at least cut out the exceptions since they're not overridable.  I haven't
  looked closely enough at linux to know how it's storing them, but I want it to be fast, since they're interrupts, so I might still
  stick to a limited table.
- I tried removing the interrupt disable instruction at the entry of the two interrupt handlers I have, and it works when the irq
  handler doesn't have it, but the trap handler does need it.  The 68k only masks the interrupts if an actual hardware interrupt
  occurs, and not on a trap, and I guess without the disable on entry to the trap, it could have another interrupt while the trap
  handler is saving the instructions.  There's only a limited set of trap instructions with specific irqs, so I could get away with
  having the two different types of handlers.  It's maybe splitting hairs over one instruction, but I do still think they'll need to
  be different anyways

2025-03-01:

- I almost have a modified context switcher that can either do what it currently did of always using Supervisor mode, or optionally
  switch to/from User mode, and which in Supervisor-only mode switches to the kernel stack before pushing all the registers, but
  it's not quite working
- I thought I'd try running it on moa last night to "quickly" find the problem, and of course moa isn't working with computie, even
  after changing the memory map to match the VME card.  I can't seem to find where the error is coming from.  It's Emulator(Misc,
  "%d0"), but that error is only created with "Error::new" and all instantiations have a complete error message instead of just the
  register name, so I'm stumped.  The code is such a mess from the time I tried adding emulator-hal.  I really need to pick it up
  and fix it, but I want to work on gloworm first
- ah! the trace function isn't even advancing the instruction, so no wonder it wasn't hitting the fault when tracing in moa

2025-03-02:

- I got thrown off by the fact that I had disabled ATA in the config, but also needed to change the boot stuff as a result.  I need
  to fix how it gets the wrong boot arguments, and also make the boot arguments default use the config value, so it's consistent

2025-03-15:

- I've been trying to rewrite the context switching code for two weeks now, and ...
- I just wandered off and did something else.  It's not that it's hard to do, but I keep just doing other things instead of working
  on it, when I set down to work on it.  Not sure if it's an effect of the medication, or a lack of interesting, or what.  But that
  said, I *do* want to only do it once, and I'm trying to incorporate everything, and read the linux m68k context switch code to
  figure out how it does it
- namely, in arch/m68k: entry.S and include/asm/entry.h
- interestingly enough, it seems to only save the higher numbered registers when it actually switches processes, and otherwise it
  doesn't touch them.  And it can do this because even though it enters the kernel's C code, as long as it doesn't actually change
  states until it's returned all the way up the call stack, out of each re-entry of the kernel, and is finally ready to return from
  the irq or syscall that entered the kernel, the stack will be exactly back to when it entered, and all the extra registers will
  have been restored as part of the C calling convention to preserve their values on the stack.  It will be as if it had just
  entered, and only pushed the scratch registers on the stack.  I'm pretty sure this is what was meant when I read that now all
  interrupts were the "fast interrupt" in Linux, as in it only saves the full context state if it's switching and otherwise only
  saves the minimum (ish) by default

- So, what I want is:
    - to be able to get the interrupt number that occurred (for the handler lookup table)
    - to configurably do what it currently does of only using the supervisor stack, or optionally using user mode
    - save the system call on the stack in a way that doesn't duplicate the values like it currently does
    - don't save all the registers unless a task switch is actually going to happen

- I think that's it.  The questions I still need to answer are: should I always save the systemcall registers, whether in a system
  call or not, or only when in a syscall instead of irq, and how do I know which is which when looking at the stack?
- also, should I keep my syscall register assignments or copy linux which uses %d1-%d5 primarily, still can't find a good reason why,
  Minix on Mac might use the same as I am, but it looks like it uses a movem to save %d0-%d2/%a0-%a1 instead of the weird order I
  have... this is kind of minor by comparison

- for the first question, I'm pretty sure linux saves all of %d0-%d5/%a0-%a2, which are all the syscall registers plus some (still
  don't know why %a2 specifically), but either way, every interrupt always saves those registers, so it doesn't try to be too fancy
  and have two ways of entering?  It looks like it.  That would certainly be easier
- ah, I have them in the slightly weird order they're in (%d0, %d1, %a0, %a1, %d2, %d3) based on the read and write syscalls, which
  (SYSCALL3) which takes an integer (%d1), and then a pointer and size (which is pointer-like).  Interestingly enough, I don't have
  any SYSCALL5's, even though I've defined it (and not 4).  Oh it's just not in unistd, but it's in socket.  And there it looks like
  it doesn't make much sense... "a" registers have int flags and the ints in %d2 and %d3 are the actual pointers

2025-03-16:

- Ohhh!  Linux is using a different kernel stack *for each task*.  That's why the context switch seemed a bit weird.  It pushes the
  basic registers to the kernel stack and I think it also keeps the exception frame on there as well.  That's why it doesn't seem to
  copy anything from the kernel stack to the user stack when switching tasks.  It just stores all the data on the kernel stack.
- I'm not sure why it's doing this yet (other than convenience, if you have lots of memory).  Unless there's a better reason, maybe
  I should avoid this to keep the memory usage down?
- what happens when a signal occurs?  I think that's the only weird case where you'd end up with 2 contexts on the user stack

- I'm kind of thinking, at least for now, I'll use only one kernel stack (per cpu, but only one cpu atm), and that kernel stack will
  always be in the ISP stack pointer, which is backwards compatible.  I won't make use of the MSP or the M bit for the time being.
- is it worth it to always switch the stack to the user stack, push the context, and then switch back to the same kernel stack and
  only push the rest of the context when switching, even though switching is probably going to be quite frequent.  Or should you
  push it to the kernel stack along with the exception frame, and copy it to the user stack when switching fully?
- or is it even best to push a0 to kernel stack, use it to push context to user stack, etc

2025-03-18:

- I think I will eventually move to a kernel stack per thread model, but for now I'll just do a single kernel thread and change
  things over more slowly.  I don't even have threads yet

2025-03-23:

- Making progress, but still don't have a working context switch that delays the switch until it's returning, and only switches if
  it's actually changing processes
- so a little while ago I figured out that there was an issue with returning from a syscall, and that was because the code that set
  that value is manipulating the context itself on the user stack.  This is a major point to note when changing the context layout.
  Previously, the register %d0 was at the top of the stack, but that's not the case now, if the extra regs are only pushed as
  needed.
- I caught this by make it do the full switch but using the new macros.  I had it working when the extra regs were pushed before the
  syscall regs, but not in the opposite direction.  Greping the code found places where proc->sp was being used, and that lead to
  finding the issue.  I moved that code to a function in syscall_entry.S so that it would be more obvious that that was happening.
  The code that actually set it was in schedule.c, so it's not supposed to know about the context format anyways
- the symptoms were that it would appear to hang when starting multitasking, but it was still context switching according to the LED

- I then tried to get the delayed switch working, and that's been a nightmare.  It usually gives a privillege violation, because the
  flags register ends up being 0 due to an invalid stack.  Using the moa emulator, I was able to figure out that (at least in some
  cases), it was doing the switch correctly the first few times, but not after that
- there is an issue with starting multitaskings since the context needs to not try to save the previous process, which is NULL.  I
  had some code to check if the previous_proc was null, but that was maybe causing more issues, so I disabled it, and that caused
  different issues
- one of the problems was that it was restoring the current_proc stack, and then saving the previous_proc stack, and not looking at
  the current_proc value again before popping, but if the check to see if the proc is the same is disabled, then it won't use the
  updated sp when popping current_proc, so for now I have it switch to current, switch to previous, and then switch back to current
- It was still having a bad switch somewhere, and moa with a breakpoint just before it starts the stack manipulation found that
  after 4 or so switches, it messes up, when trying to pop off a new stack.  The stack doesn't have the full context on it, so when
  the switching code does the swap, it pops the extra regs off the stack which aren't there and thus later on pops the wrong data
  during rte
- more grepping of the code didn't find the issue, because I didn't look at the code around it.  I tried setting a breakpoint on the
  signal code because that involved some stack manipulation, but that didn't get hit before the bad switch happened
- I can't quite remember how I clued into the process clone.  I might have been looking at new_proc and stuff, but somewhere along
  the line, I realized that the process cloning/fork was the problem.  It's cloning the current process which has an incomplete
  context on its stack, and so when it goes to actually switch procs, the new proc doesn't have the extra regs, only the syscall
  regs!
- fixing this made the privillege violation stop, so it's successfully switching, but it now hangs before the shell starts.  I
  *think* that might be because of the return value again.  I think the problem in general is that the context on the stack is not
  consistent.  If you're doing something with the stack of the current proc, then it's only got the syscall, and if you're doing
  something with any other process, it has the extended stack
- nope, trying to conditionally set the return value in the context doesn't fix the problem.  It seemed to instead make context
  switching halt.  When it's swapped from what it should be, it continues context switching and hangs before starting the shell

